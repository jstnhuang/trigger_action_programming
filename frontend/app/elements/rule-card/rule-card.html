<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/core-animated-pages/core-animated-pages.html">
<link rel="import" href="../../bower_components/core-animated-pages/transitions/slide-up.html">
<link rel="import" href="../../bower_components/core-collapse/core-collapse.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-autogrow-textarea.html">
<link rel="import" href="../../bower_components/paper-input/paper-input-decorator.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">

<link rel="import" href="../action-chooser/action-chooser.html">
<link rel="import" href="../rule-preview/rule-preview.html">
<link rel="import" href="../say-something-action/say-something-action.html">
<link rel="import" href="../step-count/step-count.html">
<link rel="import" href="../trigger-builder/trigger-builder.html">

<polymer-element name="rule-card" attributes="triggers action mode index name readOnly">
  <template>
    <link rel="stylesheet" href="rule-card.css">
    <link rel="stylesheet" href="../creator.css">
    <!-- Display a create/update interface -->
    <div id="updateWrapper">
    <template if="{{mode == 'create' || mode == 'update'}}">
      <core-collapse id="updateCollapse">
        <template if="{{mode == 'create'}}">
          <span class="ruleDesc titleRule">If <a class="changeable" on-click="{{chooseTrigger}}" title="Click to start making this rule">this</a> then that</span>
        </template>
        <template if="{{mode == 'update'}}">
          <rule-preview triggers="{{triggers}}" action="{{action}}">
        </template>
        <!-- Choose one or more triggers -->
        <div id="triggerBuilders">
          <template repeat="{{trigger, index in triggers}}">
            <trigger-builder readOnly="{{readOnly}}" mode="{{trigger.mode || mode}}" TRIGGERMODELS="{{TRIGGER_MODELS}}" trigger="{{trigger}}" triggerIndex="{{index}}" triggers="{{triggers}}" on-add-trigger="{{addTrigger}}" on-choose-action="{{chooseAction}}" on-delete-trigger="{{deleteTrigger}}"></trigger-builder>
          </template>
        </div>
        <!-- Choose an action -->
        <core-collapse class="stepCollapse" id="chooseActionCollapse">
          <step-count current="{{3 * triggers.length + 1}}" total="{{3 * triggers.length + 3}}"></step-count>
          <action-chooser selected="{{action.key}}" actions="{{ACTION_MODELS}}" on-action-selected="{{customizeAction}}" readOnly="{{readOnly}}"></action-chooser>
        </core-collapse>
        <core-collapse class="stepCollapse" id="actionOptionsCollapse">
          <step-count current="{{3 * triggers.length + 2}}" total="{{3 * triggers.length + 3}}"></step-count>
          <template if="{{action.key == 'say_something'}}">
            <say-something-action id="actionOptions" params="{{action.params}}" readOnly="{{readOnly}}"></say-something-action>
          </template>
          <paper-button class="next" raised on-click="{{confirmRule}}" title="You will have a chance to confirm your rule in the next step.">Next step</paper-button>
        </core-collapse>
        <!-- Confirm and save rule -->
        <core-collapse class="stepCollapse" id="ruleConfirmationCollapse">
          <step-count current="{{3 * triggers.length + 3}}" total="{{3 * triggers.length + 3}}"></step-count>
          <p>This is a preview of your rule. You can go back to previous steps if you want to make changes. Otherwise, click "Finish" to save this rule.</p>
          <rule-preview triggers="{{triggers}}" action="{{action}}"></rule-preview>
          <paper-input-decorator label="Enter a name for this rule" floatingLabel class="nameInput">
            <paper-autogrow-textarea id="nameArea">
              <template if="{{readOnly}}">
                <textarea id="nameInput" value="{{name}}" disabled="{{readOnly}}"></textarea>
              </template>
              <template if="{{!readOnly}}">
                <textarea id="nameInput" value="{{name}}"></textarea>
              </template>
            </paper-autogrow-textarea>
          </paper-input-decorator>
          <template if="{{readOnly}}">
            <paper-button class="next" raised on-click="{{closeRule}}" title="Click to close this rule.">Close</paper-button>
          </template>
          <template if="{{!readOnly}}">
            <paper-button class="next" raised on-click="{{saveRule}}" title="Click to save your rule.">Finish</paper-button>
          </template>
        </core-collapse>
        <div layout horizontal end-justified>
          <paper-button raised class="deleteButton" on-click="{{delete}}" title="Click to delete this rule immediately.">
            <template if="{{mode == 'create'}}">
              Cancel rule
            </template>
            <template if="{{mode == 'update'}}">
              Delete rule
            </template>
          </paper-button>
        </div>
      </core-collapse>
    </template>
    </div>
    <!-- Display a read-only summary of the rule. -->
    <template if="{{mode == 'summary'}}">
      <rule-preview triggers="{{triggers}}" action="{{action}}"></rule-preview>
      <p class="ruleName">{{name}}</p>
    </template>
  </template>
  <script>
    (function () {
      Polymer({
        mode: 'summary',
        triggers: [], // A list of trigger models for this rule, as JSON objects.
        action: {}, // The action as a JSON object.
        readOnly: false, // Whether the contents should be read only in update mode.

        ready: function() {
          if (this.mode == 'update') {
            this.async(function() {
              this.$.updateWrapper.querySelector('#updateCollapse').opened = true;
            }, null, 100);
            this.async(function() {
              this.$.updateWrapper.querySelector('#chooseActionCollapse').opened = true;
            }, null, 100);
            this.async(function() {
              this.$.updateWrapper.querySelector('#actionOptionsCollapse').opened = true;
            }, null, 100);
            this.async(function() {
              this.$.updateWrapper.querySelector('#ruleConfirmationCollapse').opened = true;
            }, null, 100);
            this.async(function() {
              var nameArea = this.$.updateWrapper.querySelector('#nameArea');
              var nameInput = this.$.updateWrapper.querySelector('#nameInput');
              nameArea.update(nameInput);
            }, null, 100);
          }
          // Core-collapse dynamically sets its overflow value to hidden. This interferes with
          // paper-dropdown, so we dynamically set the overflow to visible after the animation
          // for every core-collapse in the element.
          var updateCollapse = this.$.updateWrapper.querySelector('#updateCollapse');
          var chooseActionCollapse = this.$.updateWrapper.querySelector('#chooseActionCollapse');
          var actionOptionsCollapse = this.$.updateWrapper.querySelector('#actionOptionsCollapse');
          var ruleConfirmationCollapse = this.$.updateWrapper.querySelector('#ruleConfirmationCollapse');
          this.changeCollapseStyle(updateCollapse);
          this.changeCollapseStyle(chooseActionCollapse);
          this.changeCollapseStyle(actionOptionsCollapse);
          this.changeCollapseStyle(ruleConfirmationCollapse);
        },

        // Sets the given core-collapse's style to overflow: visible after it has finished opening.
        changeCollapseStyle: function(collapse) {
          if (!collapse) {
            return;
          }
          collapse.addEventListener('core-resize', function() {
            collapse.style.overflow = 'visible';
          });
        },

        modeChanged: function(oldMode, newMode) {
          if (newMode == 'update') {
            this.ready();
          }
          if (this.$.updateCollapse) {
            this.async(function() {
              this.$.updateCollapse.toggle();
            }, null, 50);
          }
        },

        chooseTrigger: function() {
          var builders = this.$.triggerBuilders.querySelectorAll('trigger-builder');
          for(var i=0; i<builders.length; ++i) {
            builders[i].chooseTrigger();
          }
        },

        addTrigger: function(e, triggers) {
          this.$.chooseActionCollapse.opened = false;
          this.triggers.push({mode: 'create'});
          // TODO: see if you can use onMutation throughout instead of async.
          this.onMutation(this.$.triggerBuilders, function() {
            this.chooseTrigger();
          });
        },

        deleteTrigger: function(e, detail, sender) {
          var builders = this.$.triggerBuilders.querySelectorAll('trigger-builder');
          // If there is no next trigger, reset the selected state of the previous
          // trigger.
          if (detail.index == this.triggers.length - 1 && detail.index - 1 >= 0) {
            // If the action chooser is already open, then select the "that" option.
            if (this.$.chooseActionCollapse.opened) {
              builders[detail.index - 1].selectAddAction();
            } else {
              builders[detail.index - 1].unselect();
            }
          }
          this.triggers.splice(detail.index, 1);
        },

        chooseAction: function(e, detail, sender) {
          if (detail.index >= 0) {
            this.triggers.splice(detail.index + 1, this.triggers.length);
          }
          var vr = sender.validate();
          if (!vr.isValid) {
            alert(vr.message);
            return;
          }
          this.async(function() {
            this.$.chooseActionCollapse.opened = true;
          }, null, 50);
        },

        customizeAction: function(e, detail) {
          this.action.key = detail['key'];
          this.action.displayName = detail['displayName'];
          this.async(function() {
            this.$.actionOptionsCollapse.opened = true;
          }, null, 50);
        },

        confirmRule: function() {
          var vr = this.validateAction();
          if (!vr.isValid) {
            alert(vr.message);
            return;
          }
          this.name = this.generateDescription();
          this.async(function() {
            this.$.ruleConfirmationCollapse.opened = true;
            this.$.nameArea.update(this.$.nameInput);
          }, null, 50);
        },

        validate: function() {
          if (this.mode == 'summary') {
            return {
              isValid: true
            };
          }
          var vr = this.validateTriggers();
          if (!vr.isValid) {
            return vr;
          }
          vr = this.validateAction();
          if (!vr.isValid) {
            return vr;
          }
          if (this.name == '') {
            return {
              isValid: false,
              message: 'Enter a name for this rule'
            };
          }
          return {
            isValid: true
          };
        },

        // Returns true if the rule was saved successfully.
        saveRule: function() {
          var vr = this.validate();
          if (!vr.isValid) {
            alert(vr.message);
            return false;
          }
          
          this.action.params = this.$.actionOptionsCollapse.querySelector('#actionOptions').toJsonObject();
          this.mode = 'summary';
          this.fire('save-rule');
          return true;
        },

        closeRule: function() {
          this.mode = 'summary';
        },

        // Returns the representation of this rule in a JSON-serializable format.
        // Format:
        // {
        //   triggers: [
        //     {
        //       name: 'daily_time',
        //       params: { ... }
        //     }
        //   ],
        //   action: {
        //     name: 'switch_lights',
        //     params: { ... }
        //   },
        //   name: 'If the time is ...'
        // }
        toJsonObject: function() {
          return {
            triggers: this.triggers,
            action: this.action,
            name: this.name
          };
        },

        // Generates the human-readable description of this rule.
        generateDescription: function() {
          var result = '';
          var builders = this.$.triggerBuilders.querySelectorAll('trigger-builder');
          for (var i=0; i<builders.length; ++i) {
            if (i == 0) {
              result += 'If ';
            } else {
              result += ' and ';
            }
            result += builders[i].generateDescription();
          }
          result += ', then ';
          var actionOptions = this.$.actionOptionsCollapse.querySelector('#actionOptions');
          result += actionOptions.generateDescription();
          return result;
        },

        validateTriggers: function() {
          var builders = this.$.updateWrapper.querySelectorAll('#triggerBuilders trigger-builder');
          if (builders.length == 0) {
            return {
              isValid: false,
              message: 'There must be at least one trigger'
            };
          }
          for(var i=0; i<builders.length; ++i) {
            var trigger = builders[i];
            var vr = trigger.validate();
            if (!vr.isValid) {
              return vr;
            }
          }
          return {
            isValid: true
          };
        },

        validateAction: function() {
          var action = this.$.actionOptionsCollapse.querySelector('#actionOptions');
          if (!action) {
            return {
              isValid: false,
              message: 'An action must be selected'
            };
          }
          var vr = action.validate();
          if (!vr.isValid) {
            return vr;
          }
          return {
            isValid: true
          };
        },

        delete: function() {
          this.fire('delete-rule', {index: this.index});
        },

        TRIGGER_MODELS: [
          {
            key: 'weekly_time',
            displayName: 'Weekly time',
            description: 'Makes your rule run at a certain time on certain days of the week.'
          },
        ],
        ACTION_MODELS: [
          {
            key: 'say_something',
            displayName: 'Say something',
            description: 'Makes the robot say something aloud.'
          },
        ]
      });
    })();
  </script>
</polymer-element>
